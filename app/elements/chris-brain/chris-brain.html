<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="chris-brain">
  <template>
    <style>
      :host {
        display: block;
      }

      #shield {
        height: 230px;
        width: 230px;
        position: relative;
        margin:auto;
      }

      #shield canvas {
        position: relative;
        z-index: 2;
        pointer-events: none;
      }

      #circle {
        height: 230px;
        width: 230px;
        border-radius: 230px;
        position: absolute;
        z-index: 1;
        top: 50%;
        left: 50%;
        -webkit-transform-origin: center center;
        -webkit-transform: translateX(-50%) translateY(-50%);
        -moz-transform: translateX(-50%) translateY(-50%);
        -ms-transform: translateX(-50%) translateY(-50%);
        -o-transform: translateX(-50%) translateY(-50%);
        transform: translateX(-50%) translateY(-50%);
        -webkit-transition: .5s -webkit-transform ease;
      }

    </style>

    <div id="shield" style="height: 230px;width: 230px;">
      <div id="circle"></div>
    </div>

  </template>


  <!-- external scripts -->
  <script src="../chris-brain/lib/shifty.min.js"></script>
  <script src="../chris-brain/lib/threejs.74.min.js"></script>

  <script>
  (function() {
      'use strict';
      Polymer({
        is: 'chris-brain',
        properties: {
          url: String
        },

        attached: function() {
          this.width = 230;
          this.height = 230;
          this.renderer = null;
          this.camera = null;
          this.scene = null;
          this.light = null;
          this.shield = null;
          this.shieldRotation = false;
          this.init2();
          // this.animate();
        },

        init2: function(){
          window.console.log(this.$.shield.style.width);
          window.console.log(this.width);


          this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true});
          // this.renderer.setClearColor( 0x212121, 1);
          this.renderer.setSize(this.width, this.height);
          this.$.shield.appendChild( this.renderer.domElement );

          this.camera = new THREE.PerspectiveCamera( 20, this.width / this.height, 1, 10000 );
          this.camera.position.z = 400;

          this.scene = new THREE.Scene();

          this.light = new THREE.DirectionalLight( 0xffffff );
          this.light.position.set( 0, 0, 1 );
          this.scene.add( this.light );

          var loader = new THREE.JSONLoader();
          var self = this;
          loader.load(this.url, function(geometry, materials) {
            var material = new THREE.MeshLambertMaterial( { color: 0xdddddd} );
            self.shield = new THREE.Mesh(geometry, material);
            self.shield.scale.set(6, 6, 6);
            self.scene.add(self.shield);

            // connect fun effects
            var anim = new Tweenable();

            self.$.circle.addEventListener("mouseover", function( event ) {
              anim.stop();
              anim.tween({
                from: { scale: 6 },
                to: { scale: 8 },
                duration: 500,
                easing: 'easeOutQuad',
                step: function() {
                  self.shield.scale.set(this.scale, this.scale, this.scale);
                }
              });
              self.shieldRotation = true;
            });

            self.$.circle.addEventListener("mouseleave", function( event ) {
              var destAngle = self.shield.rotation.y > Math.PI ? 2 * Math.PI : 0;
              var currentScale = self.shield.scale.x;

              anim.stop();
              anim.tween({
                from: { scale: currentScale, angle: self.shield.rotation.y },
                to: { scale: 6, angle: destAngle },
                duration: 500,
                easing: 'easeOutQuad',
                step: function() {
                  self.shield.scale.set(this.scale, this.scale, this.scale);
                  self.shield.rotation.y = this.angle;
                }
              });
              self.shieldRotation = false;
            });

            // after data loaded, start animation loop
            self.animate();
          });
        },

        animate: function() {
            requestAnimationFrame( this.animate.bind(this) );
            if (this.shieldRotation) {
               this.shield.rotation.y += this.deg2rad(2);
              if (this.shield.rotation.y > 2 * Math.PI) {
                this.shield.rotation.y = 0;
             }
            } 
            this.render();
        },

        render: function() {
          this.camera.lookAt( this.scene.position );
          this.renderer.render( this.scene, this.camera );
        },

        deg2rad: function(degrees){
          return degrees*2*Math.PI/360;
        }
      });
       })();
  </script>

</dom-module>